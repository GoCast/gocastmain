Index: webrtc/trunk/webrtc/voice_engine/transmit_mixer.cc
===================================================================
--- webrtc/trunk/webrtc/voice_engine/transmit_mixer.cc	(revision 4527)
+++ webrtc/trunk/webrtc/voice_engine/transmit_mixer.cc	(working copy)
@@ -354,7 +354,8 @@
                                        _audioFrame.data_,
                                        _audioFrame.samples_per_channel_,
                                        _audioFrame.sample_rate_hz_,
-                                       _audioFrame.num_channels_ == 2);
+                                       _audioFrame.num_channels_ == 2,
+                                       _audioLevel.Level());
       }
     }
 
Index: webrtc/trunk/webrtc/voice_engine/include/voe_external_media.h
===================================================================
--- webrtc/trunk/webrtc/voice_engine/include/voe_external_media.h	(revision 4527)
+++ webrtc/trunk/webrtc/voice_engine/include/voe_external_media.h	(working copy)
@@ -53,7 +53,7 @@
     // samples in interleaved stereo format (L0,R0,L1,R1,...).
     virtual void Process(int channel, ProcessingTypes type,
                          int16_t audio10ms[], int length,
-                         int samplingFreq, bool isStereo) = 0;
+                         int samplingFreq, bool isStereo, int level=0) = 0;
 
 protected:
     virtual ~VoEMediaProcess() {}
Index: webrtc/trunk/webrtc/build/merge_libs.gyp
===================================================================
--- webrtc/trunk/webrtc/build/merge_libs.gyp	(revision 4527)
+++ webrtc/trunk/webrtc/build/merge_libs.gyp	(working copy)
@@ -10,7 +10,7 @@
   'includes': ['common.gypi',],
   'variables': {
     'merge_libs_dependencies': [
-      '../video_engine/video_engine.gyp:video_engine_core',
+      '../../talk/libjingle.gyp:libjingle_peerconnection',
     ],
   },
   'targets': [
Index: webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_info_objc.h
===================================================================
--- webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_info_objc.h	(revision 4527)
+++ webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_info_objc.h	(working copy)
@@ -22,7 +22,7 @@
 #include "webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_info.h"
 #include "webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_utility.h"
 
-@interface VideoCaptureMacQTKitInfoObjC : NSObject{
+@interface VideoCaptureMacQTKitInfoObjC1 : NSObject{
     bool                                _OSSupportedInfo;
     NSArray*                            _captureDevicesInfo;
     NSAutoreleasePool*                    _poolInfo;
Index: webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_info_objc.mm
===================================================================
--- webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_info_objc.mm	(revision 4527)
+++ webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_info_objc.mm	(working copy)
@@ -18,7 +18,7 @@
 
 #pragma mark **** hidden class interface
 
-@implementation VideoCaptureMacQTKitInfoObjC
+@implementation VideoCaptureMacQTKitInfoObjC1
 
 // ****************** over-written OS methods ***********************
 #pragma mark **** over-written OS methods
Index: webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_info.h
===================================================================
--- webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_info.h	(revision 4527)
+++ webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_info.h	(working copy)
@@ -17,7 +17,7 @@
 #include "webrtc/system_wrappers/interface/map_wrapper.h"
 
 
-@class VideoCaptureMacQTKitInfoObjC;
+@class VideoCaptureMacQTKitInfoObjC1;
 
 namespace webrtc
 {
@@ -86,7 +86,7 @@
     virtual int32_t CreateCapabilityMap(
         const char* deviceUniqueIdUTF8);
 
-    VideoCaptureMacQTKitInfoObjC*    _captureInfo;
+    VideoCaptureMacQTKitInfoObjC1*    _captureInfo;
 };
 }  // namespace videocapturemodule
 }  // namespace webrtc
Index: webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_objc.h
===================================================================
--- webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_objc.h	(revision 4527)
+++ webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_objc.h	(working copy)
@@ -25,7 +25,7 @@
 
 #include "webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit.h"
 
-@interface VideoCaptureMacQTKitObjC : NSObject {
+@interface VideoCaptureMacQTKitObjC1 : NSObject {
   bool _capturing;
   int _frameRate;
   int _frameWidth;
Index: webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_info.mm
===================================================================
--- webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_info.mm	(revision 4527)
+++ webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_info.mm	(working copy)
@@ -21,7 +21,7 @@
 VideoCaptureMacQTKitInfo::VideoCaptureMacQTKitInfo(const int32_t id) :
     DeviceInfoImpl(id)
 {
-    _captureInfo = [[VideoCaptureMacQTKitInfoObjC alloc] init];
+    _captureInfo = [[VideoCaptureMacQTKitInfoObjC1 alloc] init];
 }
 
 VideoCaptureMacQTKitInfo::~VideoCaptureMacQTKitInfo()
Index: webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_objc.mm
===================================================================
--- webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_objc.mm	(revision 4527)
+++ webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_objc.mm	(working copy)
@@ -22,7 +22,7 @@
 using namespace webrtc;
 using namespace videocapturemodule;
 
-@implementation VideoCaptureMacQTKitObjC
+@implementation VideoCaptureMacQTKitObjC1
 
 -(id)init {
   self = [super init];
Index: webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit.h
===================================================================
--- webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit.h	(revision 4527)
+++ webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit.h	(working copy)
@@ -18,8 +18,8 @@
 #include "webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit_utility.h"
 #include "webrtc/modules/video_capture/video_capture_impl.h"
 
-@class VideoCaptureMacQTKitObjC;
-@class VideoCaptureMacQTKitInfoObjC;
+@class VideoCaptureMacQTKitObjC1;
+@class VideoCaptureMacQTKitInfoObjC1;
 
 namespace webrtc
 {
@@ -61,8 +61,8 @@
     int32_t SetCameraOutput();
 
 private:
-    VideoCaptureMacQTKitObjC*        _captureDevice;
-    VideoCaptureMacQTKitInfoObjC*    _captureInfo;
+    VideoCaptureMacQTKitObjC1*        _captureDevice;
+    VideoCaptureMacQTKitInfoObjC1*    _captureInfo;
     bool                    _isCapturing;
     int32_t            _id;
     int32_t            _captureWidth;
Index: webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit.mm
===================================================================
--- webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit.mm	(revision 4527)
+++ webrtc/trunk/webrtc/modules/video_capture/mac/qtkit/video_capture_qtkit.mm	(working copy)
@@ -71,12 +71,12 @@
     _deviceUniqueId = new char[nameLength+1];
     memcpy(_deviceUniqueId, iDeviceUniqueIdUTF8,nameLength+1);
 
-    _captureDevice = [[VideoCaptureMacQTKitObjC alloc] init];
+    _captureDevice = [[VideoCaptureMacQTKitObjC1 alloc] init];
     if(NULL == _captureDevice)
     {
         WEBRTC_TRACE(webrtc::kTraceError, webrtc::kTraceVideoCapture, id,
                      "Failed to create an instance of "
-                     "VideoCaptureMacQTKitObjC");
+                     "VideoCaptureMacQTKitObjC1");
         return -1;
     }
 
@@ -88,11 +88,11 @@
         return 0;
     }
 
-    _captureInfo = [[VideoCaptureMacQTKitInfoObjC alloc]init];
+    _captureInfo = [[VideoCaptureMacQTKitInfoObjC1 alloc]init];
     if(nil == _captureInfo)
     {
         WEBRTC_TRACE(webrtc::kTraceError, webrtc::kTraceVideoCapture, id,
-        "Failed to create an instance of VideoCaptureMacQTKitInfoObjC");
+        "Failed to create an instance of VideoCaptureMacQTKitInfoObjC1");
         return -1;
     }
 
Index: webrtc/trunk/DEPS
===================================================================
--- webrtc/trunk/DEPS	(revision 4527)
+++ webrtc/trunk/DEPS	(working copy)
@@ -51,7 +51,7 @@
     Var("chromium_trunk") + "/src/third_party/jsoncpp@" + Var("chromium_revision"),
 
   "third_party/jsoncpp/source":
-    "http://jsoncpp.svn.sourceforge.net/svnroot/jsoncpp/trunk/jsoncpp@248",
+    "http://svn.code.sf.net/p/jsoncpp/code/trunk/jsoncpp@248",
 
   "third_party/junit/":
     (Var("googlecode_url") % "webrtc") + "/deps/third_party/junit@3367",
Index: webrtc/trunk/talk/media/webrtc/webrtcvoiceengine.cc
===================================================================
--- webrtc/trunk/talk/media/webrtc/webrtcvoiceengine.cc	(revision 4527)
+++ webrtc/trunk/talk/media/webrtc/webrtcvoiceengine.cc	(working copy)
@@ -953,6 +953,35 @@
   return true;
 }
 
+bool WebRtcVoiceEngine::GetOutputMute(int *level) {
+  bool enabled;
+  if (voe_wrapper_->volume()->GetSystemOutputMute(enabled) == -1) {
+    LOG_RTCERR1(GetSystemOutputMute, enabled);
+    return false;
+  }
+  *level = enabled ? 0 : 1;
+  return true;
+}
+
+bool WebRtcVoiceEngine::GetInputVolume(int* level) {
+  unsigned int ulevel;
+  if (voe_wrapper_->volume()->GetMicVolume(ulevel) == -1) {
+    LOG_RTCERR1(GetMicVolume, level);
+    return false;
+  }
+  *level = ulevel;
+  return true;
+}
+
+bool WebRtcVoiceEngine::SetInputVolume(int level) {
+  ASSERT(level >= 0 && level <= 255);
+  if (voe_wrapper_->volume()->SetMicVolume(level) == -1) {
+    LOG_RTCERR1(SetMicVolume, level);
+    return false;
+  }
+  return true;
+}
+
 bool WebRtcVoiceEngine::SetOutputVolume(int level) {
   ASSERT(level >= 0 && level <= 255);
   if (voe_wrapper_->volume()->SetSpeakerVolume(level) == -1) {
@@ -1305,7 +1334,7 @@
   int channel_id = -1;
   bool success = false;
   uint32* processor_ssrc = NULL;
-  bool found_channel = FindChannelNumFromSsrc(ssrc, direction, &channel_id);
+  bool found_channel = FindChannelNumFromSsrc(ssrc, direction, &channel_id) || !ssrc;
   if (voice_processor == NULL || !found_channel) {
     LOG(LS_WARNING) << "Media Processing Registration Failed. ssrc: " << ssrc
         << " foundChannel: " << found_channel;
@@ -1323,7 +1352,7 @@
       }
       SignalRxMediaFrame.connect(voice_processor,
                                  &VoiceProcessor::OnFrame);
-    } else {
+    } else if (direction == MPD_TX) {
       processing_type = webrtc::kRecordingPerChannel;
       if (SignalTxMediaFrame.is_empty()) {
         register_with_webrtc = true;
@@ -1331,6 +1360,13 @@
       }
       SignalTxMediaFrame.connect(voice_processor,
                                  &VoiceProcessor::OnFrame);
+    } else {
+      processing_type = webrtc::kRecordingPreprocessing;
+      if (SignalCapMediaFrame.is_empty()) {
+        register_with_webrtc = true;
+      }
+      SignalCapMediaFrame.connect(voice_processor,
+                                  &VoiceProcessor::OnFrame);
     }
   }
   if (register_with_webrtc) {
@@ -1342,7 +1378,7 @@
                                         *this) != -1) {
       LOG(LS_INFO) << "Media Processing Registration Succeeded. channel:"
                    << channel_id;
-      *processor_ssrc = ssrc;
+      if (processor_ssrc) *processor_ssrc = ssrc;
       success = true;
     } else {
       LOG_RTCERR2(RegisterExternalMediaProcessing,
@@ -1371,10 +1407,13 @@
     signal = &SignalRxMediaFrame;
     processing_type = webrtc::kPlaybackAllChannelsMixed;
     processor_ssrc = &rx_processor_ssrc_;
-  } else {
+  } else if (channel_direction == MPD_TX) {
     signal = &SignalTxMediaFrame;
     processing_type = webrtc::kRecordingPerChannel;
     processor_ssrc = &tx_processor_ssrc_;
+  } else {
+    signal = &SignalCapMediaFrame;
+    processing_type = webrtc::kRecordingPreprocessing;
   }
 
   int deregister_id = -1;
@@ -1385,7 +1424,7 @@
       int channel_id = -1;
       bool found_channel = FindChannelNumFromSsrc(ssrc,
                                                   channel_direction,
-                                                  &channel_id);
+                                                  &channel_id) || !ssrc;
       if (signal->is_empty() && found_channel) {
         deregister_id = channel_id;
       }
@@ -1395,7 +1434,7 @@
     if (voe()->media() &&
         voe()->media()->DeRegisterExternalMediaProcessing(deregister_id,
         processing_type) != -1) {
-      *processor_ssrc = 0;
+      if (processor_ssrc) *processor_ssrc = 0;
       LOG(LS_INFO) << "Media Processing DeRegistration Succeeded. channel:"
                    << deregister_id;
     } else {
@@ -1424,6 +1463,9 @@
   if (!UnregisterProcessorChannel(MPD_TX, ssrc, voice_processor, direction)) {
     success = false;
   }
+  if (!UnregisterProcessorChannel(MPD_RX_AND_TX, ssrc, voice_processor, direction)) {
+    success = false;
+  }
   return success;
 }
 
@@ -1434,13 +1476,15 @@
                                 int16_t audio10ms[],
                                 int length,
                                 int sampling_freq,
-                                bool is_stereo) {
+                                bool is_stereo, int level) {
     talk_base::CritScope cs(&signal_media_critical_);
-    AudioFrame frame(audio10ms, length, sampling_freq, is_stereo);
+    AudioFrame frame(audio10ms, length, sampling_freq, is_stereo, level);
     if (type == webrtc::kPlaybackAllChannelsMixed) {
       SignalRxMediaFrame(rx_processor_ssrc_, MPD_RX, &frame);
     } else if (type == webrtc::kRecordingPerChannel) {
       SignalTxMediaFrame(tx_processor_ssrc_, MPD_TX, &frame);
+    } else if (type == webrtc::kRecordingPreprocessing) {
+      SignalCapMediaFrame(0, MPD_RX_AND_TX, &frame);
     } else {
       LOG(LS_WARNING) << "Media Processing invoked unexpectedly."
                       << " channel: " << channel << " type: " << type
@@ -2650,15 +2694,10 @@
 }
 
 bool WebRtcVoiceMediaChannel::MuteStream(uint32 ssrc, bool muted) {
-  int channel = (ssrc == 0) ? voe_channel() : GetSendChannelNum(ssrc);
-  if (channel == -1) {
-    LOG(LS_WARNING) << "The specified ssrc " << ssrc << " is not in use.";
+  if (engine()->voe()->volume()->SetSystemInputMute(muted) == -1) {
+    LOG_RTCERR1(SetInputMute, muted);
     return false;
   }
-  if (engine()->voe()->volume()->SetInputMute(channel, muted) == -1) {
-    LOG_RTCERR2(SetInputMute, channel, muted);
-    return false;
-  }
   return true;
 }
 
Index: webrtc/trunk/talk/media/webrtc/webrtcvoiceengine.h
===================================================================
--- webrtc/trunk/talk/media/webrtc/webrtcvoiceengine.h	(revision 4527)
+++ webrtc/trunk/talk/media/webrtc/webrtcvoiceengine.h	(working copy)
@@ -127,7 +127,10 @@
   bool SetDelayOffset(int offset);
   bool SetDevices(const Device* in_device, const Device* out_device);
   bool GetOutputVolume(int* level);
+  bool GetOutputMute(int* level);
   bool SetOutputVolume(int level);
+  bool GetInputVolume(int* level);
+  bool SetInputVolume(int level);
   int GetInputLevel();
   bool SetLocalMonitor(bool enable);
 
@@ -152,7 +155,7 @@
                        int16_t audio10ms[],
                        int length,
                        int sampling_freq,
-                       bool is_stereo);
+                       bool is_stereo, int level=0);
 
   // For tracking WebRtc channels. Needed because we have to pause them
   // all when switching devices.
@@ -224,6 +227,7 @@
   // SignalXXMediaFrame will be invoked for every audio packet.
   FrameSignal SignalRxMediaFrame;
   FrameSignal SignalTxMediaFrame;
+  FrameSignal SignalCapMediaFrame;
 
   static const int kDefaultLogSeverity = talk_base::LS_WARNING;
 
Index: webrtc/trunk/talk/media/webrtc/webrtcvideocapturer.cc
===================================================================
--- webrtc/trunk/talk/media/webrtc/webrtcvideocapturer.cc	(revision 4527)
+++ webrtc/trunk/talk/media/webrtc/webrtcvideocapturer.cc	(working copy)
@@ -190,8 +190,7 @@
   }
   factory_->DestroyDeviceInfo(info);
   if (supported.empty()) {
-    LOG(LS_ERROR) << "Failed to find usable formats for id: " << device.id;
-    return false;
+    LOG(LS_WARNING) << "Failed to find usable formats for id: " << device.id;
   }
 
   module_ = factory_->Create(0, vcm_id);
@@ -203,7 +202,9 @@
   // It is safe to change member attributes now.
   module_->AddRef();
   SetId(device.id);
-  SetSupportedFormats(supported);
+  if (!supported.empty()) {
+    SetSupportedFormats(supported);
+  }
   return true;
 }
 
Index: webrtc/trunk/talk/media/base/mediaengine.h
===================================================================
--- webrtc/trunk/talk/media/base/mediaengine.h	(revision 4527)
+++ webrtc/trunk/talk/media/base/mediaengine.h	(working copy)
@@ -129,6 +129,12 @@
   // Device configuration
   // Gets the current speaker volume, as a value between 0 and 255.
   virtual bool GetOutputVolume(int* level) = 0;
+  // Gets the current speaker mute status.
+  virtual bool GetOutputMute(int* level) = 0;
+  // Gets the current mic volume, as a value between 0 and 255.
+  virtual bool GetInputVolume(int* level) = 0;
+  // Sets the current mic volume, as a value between 0 and 255.
+  virtual bool SetInputVolume(int level) = 0;
   // Sets the current speaker volume, as a value between 0 and 255.
   virtual bool SetOutputVolume(int level) = 0;
 
@@ -231,6 +237,15 @@
   virtual bool GetOutputVolume(int* level) {
     return voice_.GetOutputVolume(level);
   }
+  virtual bool GetOutputMute(int* level) {
+    return voice_.GetOutputMute(level);
+  }
+  virtual bool GetInputVolume(int* level) {
+    return voice_.GetInputVolume(level);
+  }
+  virtual bool SetInputVolume(int level) {
+    return voice_.SetInputVolume(level);
+  }
   virtual bool SetOutputVolume(int level) {
     return voice_.SetOutputVolume(level);
   }
Index: webrtc/trunk/talk/media/base/audioframe.h
===================================================================
--- webrtc/trunk/talk/media/base/audioframe.h	(revision 4527)
+++ webrtc/trunk/talk/media/base/audioframe.h	(working copy)
@@ -36,19 +36,22 @@
       : audio10ms_(NULL),
         length_(0),
         sampling_frequency_(8000),
-        stereo_(false) {
+        stereo_(false),
+        level_(0) {
   }
-  AudioFrame(int16* audio, size_t audio_length, int sample_freq, bool stereo)
+  AudioFrame(int16* audio, size_t audio_length, int sample_freq, bool stereo, int level)
       : audio10ms_(audio),
         length_(audio_length),
         sampling_frequency_(sample_freq),
-        stereo_(stereo) {
+        stereo_(stereo),
+        level_(0) {
   }
 
   int16* GetData() { return audio10ms_; }
   size_t GetSize() const { return length_; }
   int GetSamplingFrequency() const { return sampling_frequency_; }
   bool GetStereo() const { return stereo_; }
+  int GetLevel() const { return level_; }
 
  private:
   // TODO(janahan): currently the data is not owned by this class.
@@ -57,6 +60,7 @@
   size_t length_;
   int sampling_frequency_;
   bool stereo_;
+  int level_;
 };
 
 }  // namespace cricket
Index: webrtc/trunk/talk/app/webrtc/peerconnectioninterface.h
===================================================================
--- webrtc/trunk/talk/app/webrtc/peerconnectioninterface.h	(revision 4527)
+++ webrtc/trunk/talk/app/webrtc/peerconnectioninterface.h	(working copy)
@@ -84,6 +84,7 @@
 
 namespace cricket {
 class PortAllocator;
+class ChannelManager;
 class WebRtcVideoDecoderFactory;
 class WebRtcVideoEncoderFactory;
 }
@@ -429,6 +430,9 @@
       CreateAudioTrack(const std::string& label,
                        AudioSourceInterface* source) = 0;
 
+  // Returns the channel manager.
+  virtual cricket::ChannelManager* channel_manager() = 0;
+
  protected:
   // Dtor and ctor protected as objects shouldn't be created or deleted via
   // this interface.
Index: webrtc/trunk/talk/app/webrtc/localvideosource.cc
===================================================================
--- webrtc/trunk/talk/app/webrtc/localvideosource.cc	(revision 4527)
+++ webrtc/trunk/talk/app/webrtc/localvideosource.cc	(working copy)
@@ -80,7 +80,22 @@
   {640, 360, FPS_TO_INTERVAL(30), cricket::FOURCC_ANY},
   {640, 480, FPS_TO_INTERVAL(30), cricket::FOURCC_ANY},
   {320, 240, FPS_TO_INTERVAL(30), cricket::FOURCC_ANY},
-  {320, 180, FPS_TO_INTERVAL(30), cricket::FOURCC_ANY}
+  {320, 180, FPS_TO_INTERVAL(30), cricket::FOURCC_ANY},
+  {160, 120, FPS_TO_INTERVAL(30), cricket::FOURCC_ANY},
+  {1280, 720, FPS_TO_INTERVAL(24), cricket::FOURCC_ANY},
+  {960, 720, FPS_TO_INTERVAL(24), cricket::FOURCC_ANY},
+  {640, 360, FPS_TO_INTERVAL(24), cricket::FOURCC_ANY},
+  {640, 480, FPS_TO_INTERVAL(24), cricket::FOURCC_ANY},
+  {320, 240, FPS_TO_INTERVAL(24), cricket::FOURCC_ANY},
+  {320, 180, FPS_TO_INTERVAL(24), cricket::FOURCC_ANY},
+  {160, 120, FPS_TO_INTERVAL(24), cricket::FOURCC_ANY},
+  {1280, 720, FPS_TO_INTERVAL(15), cricket::FOURCC_ANY},
+  {960, 720, FPS_TO_INTERVAL(15), cricket::FOURCC_ANY},
+  {640, 360, FPS_TO_INTERVAL(15), cricket::FOURCC_ANY},
+  {640, 480, FPS_TO_INTERVAL(15), cricket::FOURCC_ANY},
+  {320, 240, FPS_TO_INTERVAL(15), cricket::FOURCC_ANY},
+  {320, 180, FPS_TO_INTERVAL(15), cricket::FOURCC_ANY},
+  {160, 120, FPS_TO_INTERVAL(15), cricket::FOURCC_ANY}
 };
 
 MediaSourceInterface::SourceState
Index: webrtc/trunk/talk/app/webrtc/mediastreamsignaling.cc
===================================================================
--- webrtc/trunk/talk/app/webrtc/mediastreamsignaling.cc	(revision 4527)
+++ webrtc/trunk/talk/app/webrtc/mediastreamsignaling.cc	(working copy)
@@ -63,6 +63,13 @@
   bool value;
   size_t mandatory_constraints_satisfied = 0;
 
+  if(FindConstraint(constraints,
+                    "AudioCodec",
+                    &value,
+                    &mandatory_constraints_satisfied)) {
+    options->preferred_acodec_name = value;
+  }
+    
   if (FindConstraint(constraints,
                      MediaConstraintsInterface::kOfferToReceiveAudio,
                      &value, &mandatory_constraints_satisfied)) {
Index: webrtc/trunk/talk/session/media/channelmanager.cc
===================================================================
--- webrtc/trunk/talk/session/media/channelmanager.cc	(revision 4527)
+++ webrtc/trunk/talk/session/media/channelmanager.cc	(working copy)
@@ -577,6 +577,42 @@
       Bind(&MediaEngineInterface::GetOutputVolume, media_engine_.get(), level));
 }
 
+bool ChannelManager::GetOutputMute(bool* enabled) {
+  int level = 0;
+  bool ret = false;
+
+  if (initialized_) {
+    ret = worker_thread_->Invoke<bool>(
+        Bind(&MediaEngineInterface::GetOutputMute, media_engine_.get(), &level));
+    *enabled = (0 == level? false: true);
+  }
+
+  return ret;
+}
+
+bool ChannelManager::GetInputVolume(int *level) {
+  if (!initialized_) {
+    return false;
+  }
+  return worker_thread_->Invoke<bool>(
+      Bind(&MediaEngineInterface::GetInputVolume, media_engine_.get(), level));
+}
+
+bool ChannelManager::SetInputVolume(int level) {
+  bool ret = level >= 0 && level <= 255;
+  if (initialized_) {
+    ret &= worker_thread_->Invoke<bool>(
+        Bind(&MediaEngineInterface::SetInputVolume,
+             media_engine_.get(), level));
+  }
+    
+  if (ret) {
+    audio_input_volume_ = level;
+  }
+
+  return ret;
+}
+
 bool ChannelManager::SetOutputVolume(int level) {
   bool ret = level >= 0 && level <= 255;
   if (initialized_) {
Index: webrtc/trunk/talk/session/media/channelmanager.h
===================================================================
--- webrtc/trunk/talk/session/media/channelmanager.h	(revision 4527)
+++ webrtc/trunk/talk/session/media/channelmanager.h	(working copy)
@@ -142,6 +142,9 @@
                        const std::string& wave_out_device, int opts);
   bool GetOutputVolume(int* level);
   bool SetOutputVolume(int level);
+  bool GetOutputMute(bool* enabled);
+  bool GetInputVolume(int* level);
+  bool SetInputVolume(int level);
   bool IsSameCapturer(const std::string& capturer_name,
                       VideoCapturer* capturer);
   // TODO(noahric): Nearly everything called "device" in this API is actually a
@@ -289,6 +292,7 @@
   int audio_options_;
   int audio_delay_offset_;
   int audio_output_volume_;
+  int audio_input_volume_;
   std::string camera_device_;
   VideoEncoderConfig default_video_encoder_config_;
   VideoRenderer* local_renderer_;
Index: webrtc/trunk/talk/session/media/mediasession.cc
===================================================================
--- webrtc/trunk/talk/session/media/mediasession.cc	(revision 4527)
+++ webrtc/trunk/talk/session/media/mediasession.cc	(working copy)
@@ -1027,7 +1027,7 @@
   VideoCodecs video_codecs;
   DataCodecs data_codecs;
   GetCodecsToOffer(current_description, &audio_codecs, &video_codecs,
-                   &data_codecs);
+                   &data_codecs, options);
 
   if (!options.vad_enabled) {
     // If application doesn't want CN codecs in offer.
@@ -1379,7 +1379,8 @@
     const SessionDescription* current_description,
     AudioCodecs* audio_codecs,
     VideoCodecs* video_codecs,
-    DataCodecs* data_codecs) const {
+    DataCodecs* data_codecs,
+    const MediaSessionOptions& options) const {
   UsedPayloadTypes used_pltypes;
   audio_codecs->clear();
   video_codecs->clear();
@@ -1415,6 +1416,25 @@
   FindCodecsToOffer<AudioCodec>(audio_codecs_, audio_codecs, &used_pltypes);
   FindCodecsToOffer<VideoCodec>(video_codecs_, video_codecs, &used_pltypes);
   FindCodecsToOffer<DataCodec>(data_codecs_, data_codecs, &used_pltypes);
+
+  //If a preferred audio codec is specified, remove every other codec
+  //from the list except that
+  if(!options.preferred_acodec_name.empty()) {
+    std::vector<AudioCodec> acodecs;
+    for(size_t i=0; i<audio_codecs->size(); i++) {
+      if(options.preferred_acodec_name == audio_codecs->at(i).name) {
+        acodecs.push_back(audio_codecs->at(i));
+      }
+    }
+
+    if(!acodecs.empty()) {
+      audio_codecs->clear();
+      while(!acodecs.empty()) {
+        audio_codecs->push_back(acodecs.back());
+        acodecs.pop_back();
+      }
+    }
+  }
 }
 
 void MediaSessionDescriptionFactory::GetRtpHdrExtsToOffer(
Index: webrtc/trunk/talk/session/media/mediasession.h
===================================================================
--- webrtc/trunk/talk/session/media/mediasession.h	(revision 4527)
+++ webrtc/trunk/talk/session/media/mediasession.h	(working copy)
@@ -98,7 +98,8 @@
       rtcp_mux_enabled(true),
       bundle_enabled(false),
       video_bandwidth(kAutoBandwidth),
-      data_bandwidth(kDataMaxBandwidth) {
+      data_bandwidth(kDataMaxBandwidth),
+      preferred_acodec_name("") {
   }
 
   bool has_data() const { return data_channel_type != DCT_NONE; }
@@ -121,6 +122,7 @@
   // bps. -1 == auto.
   int video_bandwidth;
   int data_bandwidth;
+  std::string preferred_acodec_name;
   TransportOptions transport_options;
 
   struct Stream {
@@ -412,7 +414,8 @@
   void GetCodecsToOffer(const SessionDescription* current_description,
                         AudioCodecs* audio_codecs,
                         VideoCodecs* video_codecs,
-                        DataCodecs* data_codecs) const;
+                        DataCodecs* data_codecs,
+                        const MediaSessionOptions& options) const;
   void GetRtpHdrExtsToOffer(const SessionDescription* current_description,
                             RtpHeaderExtensions* audio_extensions,
                             RtpHeaderExtensions* video_extensions) const;
